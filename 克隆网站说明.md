# 克隆网站功能说明

## 当前实现

当前的克隆功能会：
1. 使用 Playwright 访问源网站
2. 获取渲染后的 HTML 内容
3. 在 HTML 的 `<head>` 中添加 `<base>` 标签
4. 保存到本地并启动 HTTP 服务器

## 关于 API 请求的说明

### 当前行为
克隆的网站中的 JavaScript 代码仍然会调用**原始网站的 API**。这是因为：
- 我们只克隆了前端页面（HTML/CSS/JS）
- JavaScript 中的 API 请求地址仍然指向原始服务器
- 这是**预期行为**，因为我们没有克隆后端服务

### 为什么这样设计？

1. **静态内容克隆**：我们的系统主要用于克隆网站的**外观和布局**
2. **功能保持**：通过保留原始 API 调用，克隆的网站仍然可以正常工作
3. **简单高效**：不需要复制整个后端系统

### 使用场景

这个克隆系统适合以下场景：
- ✅ 预览和测试网站外观
- ✅ 保存网站快照
- ✅ 本地访问远程网站（通过自定义域名）
- ✅ 学习和研究网站结构
- ❌ 完全离线使用（需要网络连接到原始 API）
- ❌ 替代原始网站（功能依赖原始后端）

## 如果需要完全独立的克隆

如果你需要克隆的网站完全独立于原始服务器，需要：

### 方案 1：添加 API 代理（推荐）
在我们的系统中添加一个代理层，拦截 API 请求并转发到原始服务器。

**优点**：
- 可以缓存 API 响应
- 可以修改请求/响应
- 克隆的网站看起来完全独立

**缺点**：
- 需要额外的代理服务
- 可能违反原始网站的服务条款

### 方案 2：下载所有资源
下载所有 CSS、JS、图片、字体等静态资源到本地。

**优点**：
- 静态资源完全本地化
- 不依赖原始服务器的静态文件

**缺点**：
- 仍然需要原始 API
- 占用更多磁盘空间
- 实现复杂

### 方案 3：完整克隆（包括后端）
这需要：
- 克隆前端代码
- 克隆后端代码
- 克隆数据库
- 配置完整的运行环境

**这超出了本系统的设计范围**

## 当前的 `<base>` 标签作用

我们在克隆的 HTML 中添加了：
```html
<base href="https://原始网站域名/">
```

这个标签的作用：
- 确保所有相对路径（CSS、JS、图片）指向原始网站
- 保证克隆的页面能正确加载所有资源
- 维持网站的完整功能

## 示例

假设克隆 `https://example.com/page`：

**克隆后的 HTML**：
```html
<!DOCTYPE html>
<html>
<head>
    <base href="https://example.com/">
    <link rel="stylesheet" href="/css/style.css">  <!-- 实际加载：https://example.com/css/style.css -->
    <script src="/js/app.js"></script>              <!-- 实际加载：https://example.com/js/app.js -->
</head>
<body>
    <!-- 页面内容 -->
</body>
</html>
```

**JavaScript 中的 API 调用**：
```javascript
// 这些请求仍然发送到原始服务器
fetch('/api/data')  // 实际请求：https://example.com/api/data
```

## 总结

- ✅ 当前实现：克隆前端页面，保留原始 API 调用
- ✅ 适用场景：预览、测试、学习网站外观和结构
- ⚠️ 限制：需要网络连接，功能依赖原始后端
- 💡 如需完全独立：需要实现 API 代理或完整克隆后端系统
